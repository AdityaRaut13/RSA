#include <cstdlib>
#include <iostream>
#include <bits/stdc++.h>
#include <math.h>
#include <string>
#include <sys/select.h>
typedef long long unsigned llu;
typedef long unsigned lu;
std::vector<llu> PRIME_ARRAY;
bool is_prime(llu number)
{
	long double limit = sqrt(number);
	for(llu i = 2; i < limit; i++)
	{
		if(number % i == 0)
			return false;
	}
	return true;
}
void compute_list_prime(int number)
{
	int i = 1;
	llu j = 2;
	while(i != number)
	{
		if(is_prime(j))
		{
			PRIME_ARRAY.push_back(j);
			i++;
		}
		j++;
	}
}
inline llu select_random_prime()
{
	return PRIME_ARRAY[rand() % PRIME_ARRAY.size()];
}
void initialize()
{
	int number;
	std::cout << "enter the number of prime number to select : ";
	std::cin >> number;
	compute_list_prime(number);
	llu p = select_random_prime(), q = select_random_prime();
	std::cout << p << " " << q;
	std::cout << "\n";
}
int exponential_mod(lu base, lu exponent, lu mod)
{
	llu result = 1;
	base = base % mod;
	if(base == 0)return 0;
	while(exponent > 0)
	{
		if(exponent & 1)
			result = (result * base) % mod;
		exponent = exponent >> 1;
		base = (base * base) % mod;
	}
	return result;
}
std::vector<int> encryption(std::vector<int> plaintext, llu e, llu N)
{
	std::vector<int> result;
	for(int i = 0; i < plaintext.size(); i++)
		result.push_back(exponential_mod(plaintext[i], e, N));
	return result;
}
std::vector<int> decryption(std::vector<int> ciphertext, llu d, llu N)
{
	std::vector<int> result;
	for(int i = 0; i < ciphertext.size(); i++)
		result.push_back(exponential_mod(ciphertext[i], d, N));
	return result;
}
int gcd(int number1, int number2)
{
	int temp;
	while(number2 != 0)
	{
		temp = number2;
		number2 = number1 % number2;
		number1 = temp;
	}
	return number1;
}
llu select_encryption_key(llu phi_of_N)
{
	std::vector<llu> possible_e;
	for(llu e = 2; e < phi_of_N; e++)
	{
		if(gcd(phi_of_N, e) == 1)
			possible_e.push_back(e);
	}
	return possible_e[rand() % possible_e.size()];
}
long long unsigned find_multiplicative_inverse(llu e, llu phi_of_N)
{
	// assuming e and phi_of_N are relatively prime.
	long long int remainder, quotient, t0 = 0, t1 = 1, t, temp = phi_of_N;
	if(e > phi_of_N)
		e %= phi_of_N;
	quotient = phi_of_N / e;
	remainder = phi_of_N % e;
	while(remainder != 0)
	{
		t = t0 - (quotient * t1);
		phi_of_N = e;
		e = remainder;
		t0 = t1;
		t1 = t;
		quotient = phi_of_N / e;
		remainder = phi_of_N % e;
	}
	return t1 < 0 ? (t1 + temp) % temp : t1 % temp;
}
std::vector<std::vector<llu>> key_generation()
{
	std::vector<std::vector<llu>> public_private_key;
	std::vector<llu> public_key, private_key;
	compute_list_prime(10);
	//llu p=select_random_prime(),q=select_random_prime();
	llu p = 17, q = 11;
	llu N = p * q;
	llu phi_of_N = (p - 1) * (q - 1);
	llu e = select_encryption_key(phi_of_N);
	llu d = find_multiplicative_inverse(e, phi_of_N);
	public_key.push_back(e);
	public_key.push_back(N);
	private_key.push_back(d);
	private_key.push_back(p);
	private_key.push_back(q);
	public_private_key.push_back(public_key);
	public_private_key.push_back(private_key);
	return public_private_key;
}
auto print = [](const auto &remark, const auto &vector)
{
	std::cout << remark;
	for(auto i : vector)
		std::cout << i << " ";
	std::cout << std::endl;
};
int main()
{
	std::vector<std::vector<llu>> key_generated = key_generation();
	int number = 0;
	std::vector<int> plaintext;
	print("The public key : ", key_generated[0]);
	print("The private key : ", key_generated[1]);
	std::cout << "enter the positive integer (press -1 to exit ) : ";
	while(number != -1)
	{
		std::cin >> number;
		if(number == -1) break;
		plaintext.push_back(number);
	}
	std::vector<int> ciphertext = encryption(plaintext, key_generated[0][0], key_generated[0][1]);
	print("The ciphertext : ", ciphertext);
	std::vector<int> plaintext_generated = decryption(ciphertext, key_generated[1][0], key_generated[0][1]);
	print("The plaintext generated by the decryption function  : ", plaintext_generated);
	return 0;
}
